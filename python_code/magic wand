import tkinter as tk
from tkinter import filedialog
from PIL import Image, ImageTk
import cv2
import numpy as np




def zaladuj_obraz(okno, suwak, clear_button):
    obraz = Image.open("obraz.JPG")  # Zaktualizowana ścieżka do pliku
    okno.obraz_pil = obraz
    aktualizuj_obraz(okno)
    okno.bind("<ButtonRelease-1>", lambda event: magic_wand(event, okno, suwak.get(), clear_button))
    okno.bind("<Configure>", lambda event: aktualizuj_obraz(okno))  # Dynamiczna aktualizacja rozmiaru
def aktualizuj_obraz(okno):
    if hasattr(okno, 'obraz_pil'):
        obraz = okno.obraz_pil
        okno_width = okno.winfo_width()
        okno_height = okno.winfo_height()
        obraz = obraz.resize((okno_width, okno_height), Image.LANCZOS)
        foto = ImageTk.PhotoImage(obraz)
        okno.create_image(0, 0, image=foto, anchor="nw")
        okno.foto = foto
        okno.obraz = obraz  # Save the resized PIL image
def magic_wand(event, okno, czulosc, clear_button):
    x, y = event.x, event.y
    obraz_pil = okno.obraz
    obraz_cv2 = cv2.cvtColor(np.array(obraz_pil), cv2.COLOR_RGB2BGR)
    mask = np.zeros((obraz_cv2.shape[0] + 2, obraz_cv2.shape[1] + 2), np.uint8)
    seed_point = (x, y)
    seed_point_mask = (x + 1, y + 1)  # Dodaj 1, ponieważ maska ma dodatkowy wiersz i kolumnę
    lo_diff = (czulosc, czulosc, czulosc)
    up_diff = (czulosc, czulosc, czulosc)
    b, g, r = obraz_cv2[seed_point_mask[1], seed_point_mask[0]]
    if b > 245 and g > 245 and r > 245:
        return
    cv2.floodFill(obraz_cv2, mask, seed_point_mask, (0, 0, 0), lo_diff, up_diff, flags=cv2.FLOODFILL_MASK_ONLY | cv2.FLOODFILL_FIXED_RANGE)
    contours, _ = cv2.findContours(mask[1:-1, 1:-1], cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    height, width = obraz_cv2.shape[:2]
    color = (0, 255, 0)
    for cnt in contours:
        for point in cnt:
            if point[0][0] <= 1 or point[0][0] >= width - 2 or point[0][1] <= 1 or point[0][1] >= height - 2:
                color = (255, 0, 0)  # Zmiana koloru na czerwony jeśli przy krawędzi
                break
    cv2.drawContours(obraz_cv2, contours, -1, color, 2)
    wynikowy_obraz = Image.fromarray(cv2.cvtColor(obraz_cv2, cv2.COLOR_BGR2RGB))
    wynikowe_foto = ImageTk.PhotoImage(wynikowy_obraz)
    okno.create_image(0, 0, image=wynikowe_foto, anchor="nw")
    okno.foto = wynikowe_foto
def clear_selection(okno, suwak, clear_button):
    okno.delete("all")
    zaladuj_obraz(okno, suwak, clear_button)
def main():
    root = tk.Tk()
    root.title("Kreator wycinania obrazów")
    okno = tk.Canvas(root)
    okno.pack(fill="both", expand=True)
    suwak = tk.Scale(root, from_=0, to=255, orient="horizontal", label="Czułość")
    suwak.pack()
    clear_button = tk.Button(root, text="Clear", width=10, command=lambda: clear_selection(okno, suwak, clear_button))
    clear_button.pack()
    okno.start_x = None
    okno.start_y = None
    okno.end_x = None
    okno.end_y = None
    okno.rect = None
    zaladuj_obraz(okno, suwak, clear_button)
    root.mainloop()



if __name__ == "__main__":
    main()



if __name__ == "__main__":
    main()
